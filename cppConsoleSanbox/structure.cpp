#include "pch.h"
#include "structure.h"
#include <algorithm>
#include <deque>
#include <iostream>
#include <list>
#include <string>
#include <vector>

//tryVector - vector stores elements at contiguous memory locations like an array
//---------------------------------------------------------------------------------
struct RandomGenerator {
	int maxValue;
	RandomGenerator(int max) : maxValue(max) {}
	int operator()() { return rand() % maxValue; }
};

void tryVector() {
	// Initialize a vector with 10 ints of value 0
	std::vector<int> vecOfRandomNums(10);

	// Generate 10 random numbers by lambda func and fill it in vector
	std::generate(vecOfRandomNums.begin(), vecOfRandomNums.end(), []() {
		return rand() % 100;
	});

	std::cout << "Random Number Generated by Lambda Function" << std::endl;
	for (int val : vecOfRandomNums) std::cout << val << std::endl;

	// Generate 10 random numbers by a Functor and fill it in vector
	std::generate(vecOfRandomNums.begin(), vecOfRandomNums.end(), RandomGenerator(500));

	std::cout << "Random Number Generated by Functor" << std::endl;
	for (int val : vecOfRandomNums)	std::cout << val << std::endl;
};

//tryDeque
//-----------------
void tryDeque() {
	std::deque<int> dequeObj;

	dequeObj.push_back(5);
	dequeObj.push_back(6);

	for (int i = 0; i < dequeObj.size(); i++)
		std::cout << dequeObj[i] << " ";
	std::cout << std::endl;

	dequeObj.push_front(4);
	dequeObj.push_front(3);

	for (int i = 0; i < dequeObj.size(); i++)
		std::cout << dequeObj[i] << " ";
	std::cout << std::endl;

	dequeObj.pop_back();

	for (int i = 0; i < dequeObj.size(); i++)
		std::cout << dequeObj[i] << " ";
	std::cout << std::endl;

	dequeObj.pop_front();

	for (int i = 0; i < dequeObj.size(); i++)
		std::cout << dequeObj[i] << " ";
	std::cout << std::endl;
}

//tryList - std::list is sequential STL container that is internally implemented as doubly linked list.
//-------------
void tryList() {
	std::list<int> listOfNumbers;

	//Inserting elements at end in list
	listOfNumbers.push_back(5);
	listOfNumbers.push_back(6);

	//Inserting elements at front in list
	listOfNumbers.push_front(2);
	listOfNumbers.push_front(1);
	//Inserting elements in between the list using  insert(pos,elem) member function. 
	// Let's iterate to 3rd position
	std::list<int>::iterator it = listOfNumbers.begin();
	it++; it++;
	// Iterator 'it' is at 3rd position.
	listOfNumbers.insert(it, 4);
	while (it != listOfNumbers.end()) {
		std::cout << (*it) << "  ";
		it++;
	}
	std::cout << std::endl;

	//Erasing elements in between the list using erase(position) member function. 
	// Let's iterate to 4th position
	it = listOfNumbers.begin();
	it++;    it++; it++;
	// Iterator 'it' is at 4th position. Now erase this element.
	listOfNumbers.erase(it);

	//Lets remove all elements with value greater than 9. 
	listOfNumbers.remove_if([](int elem) {
		if (elem > 9) return true;
		else return false;
	});

	std::for_each(listOfNumbers.begin(), listOfNumbers.end(), [](int obj) {
		std::cout << "Number: " << obj << std::endl;
	});
}

//trySort
//--------------------
	class Person {
	public:
		std::string m_name;
		int m_id;
		Person(std::string name, int id) : m_name(name), m_id(id) { }

		bool operator <(const Person & obj) {
			if (m_id < obj.m_id) return true;
			else return false;
		}
	};

	struct PersonCompartor {
		bool operator()(const Person & first, const Person & sec) {
			if (first.m_name < sec.m_name) return true;
			else return false;
		}
	};


	void trySort() {
		//1. String
		std::vector<std::string> vecOfStrings;
		vecOfStrings.push_back("bbb");
		vecOfStrings.push_back("fff");
		vecOfStrings.push_back("aaa");
		vecOfStrings.push_back("ccc");
		vecOfStrings.push_back("abc");

		std::sort(vecOfStrings.begin(), vecOfStrings.end());

		std::for_each(vecOfStrings.begin(), vecOfStrings.end(), [](std::string str) {
			std::cout << str << " , ";
		});
		std::cout << std::endl;

		// 2. Person
		std::vector<Person> vecOfPersons = { Person("aaa", 7), Person("kkk", 3),
			Person("ddd", 5), Person("abc", 2) };

		std::sort(vecOfPersons.begin(), vecOfPersons.end());

		std::cout << "Sorted Persons List based on ID\n";
		std::for_each(vecOfPersons.begin(), vecOfPersons.end(), [](Person & obj) {
			std::cout << obj.m_id << " :: " << obj.m_name << std::endl;
		});
		// 3. Function Object
		std::sort(vecOfPersons.begin(), vecOfPersons.end(), PersonCompartor());

		std::cout << "Sorted Persons List based on Name using Func Object\n";
		std::for_each(vecOfPersons.begin(), vecOfPersons.end(), [](Person & obj) {
			std::cout << obj.m_id << " :: " << obj.m_name << std::endl;
		});

		// 4. Lambda    
		std::sort(vecOfPersons.begin(), vecOfPersons.end(), [](const Person & first, const Person & sec) {
			if (first.m_name < sec.m_name)
				return true;
			else
				return false;
		});
		std::cout << "Sorted Persons List based on lambda sorting\n";
		std::for_each(vecOfPersons.begin(), vecOfPersons.end(), [](Person & obj) {
			std::cout << obj.m_id << " :: " << obj.m_name << std::endl;
		});
	}

	// LinkedList
	//---------------------------------------------
	struct ListNode {
		double value;
		ListNode *next;
	};

	void tryLinkedList() {
		ListNode *head = nullptr;
		head = new ListNode;
		head->value = 12.5;
		head->next = nullptr;

		ListNode *secondPtr = new ListNode;
		secondPtr->value = 13.5;
		secondPtr->next = nullptr;
		head->next = secondPtr;

		std::cout << "First item is " << head->value << std::endl;
		std::cout << "Second item is " << head->next->value << std::endl;
	}
